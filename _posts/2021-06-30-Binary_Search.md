---
layout: single
title: "Binary Search"
categories:
    - Python
tags:
    - Python
    - Algorithms
    - Problem Solving
use_math: true
---

# Idea

주어진 문제를 다음과 같이 모델링할 수 있으면, 이진탐색(Binary Search) 알고리즘을 적용하여 문제를 해결할 수 있다.

> 정렬되고 메모리에 적재된 정수 $A_0, A_1, A_2, A_3, ..., A_{N-1}$이 주어졌을 때, 주어진 정수 $X$에 대하여 $A_i = X$를 만족하는 $i$를 찾는다. $X$가 입력에 존재하지 않는다면 $i = -1$을 반환한다.

주어진 리스트를 왼쪽에서 오른쪽으로 스캔하는 것이 자명한 해법이고, 이 방법은 선형 시간이 걸린다. 그러나 이러한 알고리즘은 주어진 리스트가 정렬돼있다는 이점을 활용하지 못하며, 따라서 최고의 해법이라 할 수 없을 것이다. 더 나은 전략으로는 주어진 $X$가 리스트의 중앙에 위치한 요소인지 확인해보는 것이다. 만약 그렇다면 답은 손쉽게 구할 수 있다. 만약 $X$가 중앙에 있는 요소보다 작다면, 그 요소보다 왼쪽에 위치한 하위 리스트에 같은 전략을 써볼 수 있다. 같은 방식으로,  만약 $X$가 중앙에 있는 요소보다 크다면, 오른쪽 절반을 살펴본다.

# Code

```python
def binary_search(a, x):
    low, high = 0, len(a) - 1
    while low <= high:
        mid = (low + high) // 2
        if a[mid] < x:
            low = mid + 1
        elif a[mid] > x:
            high = mid - 1
        else:
            return mid

    return -1  # -1 means "Not Found"
```

# Time Complexity

while 루프 안에서 이루어지는 모든 작업은 매 반복마다 명백히 $O(1)$의 시간복잡도를 갖으므로, 전체 시간복잡도 분석은 while 루프의 반복횟수에 달려있다. 루프는 `high - low`의 값이 `n - 1`일 때 시작해서 `high - low`의 값이 `-1`보다 작거나 같을 때 종료된다. 매 반복에서 `high - low`의 값은 그 이전의 값보다 최소한 절반이 되므로 루프의 반복횟수는 최대 $\lceil \log(n - 1) \rceil + 2$가 된다. 예를 들어 `high - low`의 값이 `128`일 경우, 매 반복 이후의 `high - low`의 최대값들은 `64, 32, 16, 8, 4, 2, 1, 0, -1`이 된다. 따라서 실행시간은 $O(\log{n})$의 시간복잡도를 갖는다. 이와 동치적으로, 실행시간에 대해 recursive formula를 작성해볼 수도 있지만, 실제로 무슨 일이 벌어지고 있고 또한 왜 벌어지고 있는지 이해하고 있다면 이러한 방식의 brute force 접근은 보통 불필요하다.

# More

이진탐색은 일종의 데이터구조 구현으로 볼 수도 있다. 이진탐색은 $Find$ 연산을 $O(\log{n})$의 시간복잡도로 지원하지만, 그외의 모든 연산들(특히 $Insert$ 연산)은 $O(n)$의 시간복잡도를 요구한다. 실제 응용에서 데이터가 정적일 경우(삽입과 삭제가 허용되지 않음을 의미), 이진탐색은 굉장히 유용할 수 있다. 입력이 한번 정렬될 필요는 있지만, 한번 정렬된 이후에는 접근하는 것이 매우 빠르다. 화학과 물리에 나오는 주기율표에 대한 정보를 유지보수하는 프로그램이 그 예다. 새 원소가 추가되는 일이 빈번하지 않으므로, 주기율표는 상대적으로 안정적이다. 원소들의 이름은 정렬된 상태로 유지될 수 있다. 주기율표에는 약 110개 정도의 원소밖에 없으므로 최대 8번의 접근이면 우리가 원하는 원소를 찾을 수 있다. 순차적인 탐색을 수행하는 것은 훨씬 더 많은 접근을 요구한다.

# References

- Data Structures and Algorithm Analysis In C, Mark Allen Weiss, 1996, 2/E
